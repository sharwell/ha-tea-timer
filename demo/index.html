<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Tea Timer Card Preview</title>
    <script type="module" src="../src/index.ts"></script>
    <style>
      body {
        margin: 0;
        padding: 32px;
        font-family: sans-serif;
        background: #f5f7fa;
      }

      main {
        display: grid;
        gap: 24px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 24px;
      }

      .controls button {
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: white;
        cursor: pointer;
      }

      .controls button:active {
        transform: translateY(1px);
      }

      .controls label {
        display: flex;
        flex-direction: column;
        font-size: 0.9rem;
      }

      .controls select,
      .controls input {
        padding: 6px 10px;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        min-width: 160px;
      }

      .automation {
        margin-top: 24px;
        background: white;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 12px;
        padding: 16px;
      }

      .automation h2 {
        margin: 0 0 8px;
        font-size: 1.1rem;
      }

      .automation ol {
        margin: 12px 0 0;
        padding-left: 24px;
        display: grid;
        gap: 8px;
        font-variant-numeric: tabular-nums;
      }
    </style>
  </head>
  <body>
    <h1>Tea Timer Card Preview</h1>
    <main>
      <tea-timer-card></tea-timer-card>
      <tea-timer-card></tea-timer-card>
    </main>
    <section class="controls" aria-label="Timer controls">
      <button type="button" id="btn-idle">Set idle</button>
      <button type="button" id="btn-run">Set running (2:30)</button>
      <button type="button" id="btn-estimate">Set running (estimated)</button>
      <button type="button" id="btn-finish">Emit finished event</button>
      <button type="button" id="btn-unavailable">Mark unavailable</button>
      <button type="button" id="btn-disconnect">Disconnect</button>
      <button type="button" id="btn-reconnect">Reconnect</button>
      <button type="button" id="btn-fail-service">Fail next service call</button>
      <label>
        Interaction mode
        <select id="interaction-mode">
          <option value="restart">Mode A — Restart on tap</option>
          <option value="pause-double">Mode B — Pause + double-tap restart</option>
          <option value="pause-long">Mode C — Pause + long-press restart</option>
        </select>
      </label>
      <label>
        Double-tap window (ms)
        <input
          id="doubletap-window"
          type="number"
          min="200"
          max="500"
          step="10"
          value="300"
          disabled
        />
      </label>
      <label>
        Long-press action
        <select id="longpress-action" disabled>
          <option value="restart">Restart timer</option>
          <option value="open_preset_picker">Focus preset list</option>
          <option value="open_card_menu">Open card menu</option>
          <option value="none">No action</option>
        </select>
      </label>
    </section>
    <section class="automation" aria-label="Demo automation log">
      <h2>Automation listener</h2>
      <p>
        This demo automation listens for <code>timer.finished</code> on
        <code>timer.kitchen_tea</code> and logs the finish time. The entries below include the
        approximate delay until the card overlay reports "Done".
      </p>
      <ol id="automation-log" reversed></ol>
    </section>
    <script type="module">
      const READY_STATES = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 };

      class DemoSocket {
        constructor() {
          this.readyState = READY_STATES.OPEN;
          this._listeners = new Map();
        }

        addEventListener(type, handler) {
          const listeners = this._listeners.get(type) ?? new Set();
          listeners.add(handler);
          this._listeners.set(type, listeners);
        }

        removeEventListener(type, handler) {
          this._listeners.get(type)?.delete(handler);
        }

        _emit(type) {
          const listeners = Array.from(this._listeners.get(type) ?? []);
          listeners.forEach((listener) => {
            try {
              listener({});
            } catch (error) {
              console.error(error);
            }
          });
        }

        close() {
          if (this.readyState === READY_STATES.CLOSED) {
            return;
          }
          this.readyState = READY_STATES.CLOSED;
          this._emit("close");
        }

        open() {
          this.readyState = READY_STATES.OPEN;
          this._emit("open");
        }

        error() {
          this._emit("error");
        }
      }

      class DemoConnection {
        constructor() {
          this._listeners = new Map();
          this.socket = new DemoSocket();
        }

        async subscribeMessage(callback, message) {
          const eventType = message?.event_type;
          if (!eventType) {
            return () => {};
          }

          const listeners = this._listeners.get(eventType) ?? new Set();
          listeners.add(callback);
          this._listeners.set(eventType, listeners);

          return () => {
            listeners.delete(callback);
          };
        }

        emit(eventType, data) {
          const listeners = this._listeners.get(eventType);
          if (!listeners) {
            return;
          }

          const message = { event_type: eventType, data };
          listeners.forEach((listener) => listener(message));
        }
      }

      function toDuration(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60)
          .toString()
          .padStart(2, "0");
        const seconds = Math.floor(totalSeconds % 60)
          .toString()
          .padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      }

      function createEntity(entityId, state, durationSeconds, remainingSeconds) {
        const now = new Date();
        return {
          entity_id: entityId,
          state,
          attributes: {
            duration: toDuration(durationSeconds),
            ...(remainingSeconds !== undefined ? { remaining: toDuration(remainingSeconds) } : {}),
          },
          last_changed: now.toISOString(),
          last_updated: now.toISOString(),
        };
      }

      function cloneEntity(entity) {
        return JSON.parse(JSON.stringify(entity));
      }

      function createDemoEnvironment(entityId, initialDurationSeconds = 240) {
        const environment = {};
        const connection = new DemoConnection();
        const states = {};
        let durationSeconds = initialDurationSeconds;
        let current = createEntity(entityId, "idle", durationSeconds, durationSeconds);
        let finishTimerHandle;
        let timerEndTimestamp;
        let pausedRemainingSeconds;
        let shouldFailCall = false;
        states[entityId] = current;

        function emitState(newState) {
          const oldState = current;
          current = newState;
          states[entityId] = newState;
          connection.emit("state_changed", {
            entity_id: entityId,
            old_state: oldState,
            new_state: newState,
          });
        }

        function clearFinishTimer() {
          if (finishTimerHandle !== undefined) {
            clearTimeout(finishTimerHandle);
            finishTimerHandle = undefined;
          }
        }

        function scheduleFinish(secondsRemaining) {
          clearFinishTimer();
          if (secondsRemaining <= 0) {
            Promise.resolve().then(() => environment.emitFinished());
            return;
          }

          finishTimerHandle = setTimeout(() => {
            finishTimerHandle = undefined;
            environment.emitFinished();
          }, secondsRemaining * 1000);
        }

        function getRemainingSeconds() {
          if (current.state === "paused") {
            return pausedRemainingSeconds ?? durationSeconds;
          }

          if (current.state === "active") {
            if (typeof timerEndTimestamp === "number") {
              return Math.max(0, Math.ceil((timerEndTimestamp - Date.now()) / 1000));
            }
            return durationSeconds;
          }

          return durationSeconds;
        }

        Object.assign(environment, {
          connection,
          hass: {
            locale: { language: "en" },
            states,
            connection,
            services: {
              timer: {
                start: {},
                cancel: {},
                change: {},
                pause: {},
              },
            },
            async callService(domain, service, data) {
              if (shouldFailCall) {
                shouldFailCall = false;
                throw new Error("demo service failure");
              }

              if (domain !== "timer") {
                return undefined;
              }

              if (service === "start") {
                const hasDuration = data && data.duration !== undefined;
                const requestedDuration = hasDuration ? Number(data.duration) : undefined;
                const isResume = !hasDuration && current.state === "paused";

                if (isResume) {
                  const resumeSeconds = getRemainingSeconds();
                  environment.setRunning(resumeSeconds, true);
                  connection.emit("timer.restarted", { entity_id: entityId });
                  return undefined;
                }

                const runDuration = Math.max(1, Number.isFinite(requestedDuration) ? Number(requestedDuration) : durationSeconds);
                durationSeconds = runDuration;
                environment.setRunning(runDuration, true, runDuration);
                connection.emit("timer.started", { entity_id: entityId });
                return undefined;
              }

              if (service === "cancel") {
                environment.setIdle();
                return undefined;
              }

               if (service === "pause") {
                 const remaining = getRemainingSeconds();
                 environment.setPaused(remaining);
                 connection.emit("timer.paused", { entity_id: entityId });
                 return undefined;
               }

               if (service === "change") {
                 const deltaSeconds = Number(data?.duration ?? 0);
                 if (!Number.isFinite(deltaSeconds) || deltaSeconds === 0) {
                   return undefined;
                 }

                 const updated = Math.max(0, getRemainingSeconds() + deltaSeconds);
                 if (current.state === "paused") {
                   environment.setPaused(updated);
                 } else if (current.state === "active") {
                   environment.setRunning(updated, true);
                 }
                 return undefined;
               }

              return undefined;
            },
          },
          setIdle() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            emitState(createEntity(entityId, "idle", durationSeconds, durationSeconds));
          },
          setRunning(remainingSeconds, includeRemaining = true, totalDurationSeconds = durationSeconds) {
            const safeTotal = Math.max(1, Math.round(totalDurationSeconds));
            const safeRemaining = Math.max(0, Math.round(remainingSeconds ?? safeTotal));
            durationSeconds = safeTotal;
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = Date.now() + safeRemaining * 1000;
            const remaining = includeRemaining ? safeRemaining : undefined;
            const entity = createEntity(entityId, "active", durationSeconds, remaining);
            if (!includeRemaining && safeRemaining <= durationSeconds) {
              const startTime = Date.now() - (durationSeconds - safeRemaining) * 1000;
              const lastChanged = new Date(startTime).toISOString();
              entity.last_changed = lastChanged;
              entity.last_updated = lastChanged;
            }
            emitState(entity);
            scheduleFinish(safeRemaining);
          },
          setPaused(remainingSeconds) {
            const safeRemaining = Math.max(0, Math.round(remainingSeconds ?? getRemainingSeconds()));
            pausedRemainingSeconds = safeRemaining;
            timerEndTimestamp = undefined;
            clearFinishTimer();
            emitState(createEntity(entityId, "paused", durationSeconds, safeRemaining));
          },
          setUnavailable() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            const now = new Date().toISOString();
            emitState({
              entity_id: entityId,
              state: "unavailable",
              attributes: {},
              last_changed: now,
              last_updated: now,
            });
          },
          emitFinished() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            connection.emit("timer.finished", {
              entity_id: entityId,
            });
            setTimeout(() => {
              environment.setIdle();
            }, 400);
          },
          disconnect() {
            connection.socket.close();
          },
          reconnect() {
            connection.socket.open();
            emitState(cloneEntity(current));
          },
          failNextServiceCall() {
            shouldFailCall = true;
          },
        });

        return environment;
      }

      const cards = Array.from(document.querySelectorAll("tea-timer-card"));
      const baseConfig = {
        title: "Kitchen Tea Timer",
        entity: "timer.kitchen_tea",
        defaultPreset: "Black",
        presets: [
          { label: "Green", durationSeconds: 120 },
          { label: "Black", durationSeconds: 240 },
          { label: "Herbal", durationSeconds: 300 },
        ],
      };
      const configs = [
        { ...baseConfig },
        {
          title: "Office Break Timer",
          presets: [],
        },
      ];

      const environment = createDemoEnvironment("timer.kitchen_tea", 240);
      cards.forEach((card, index) => {
        card.setConfig(configs[index]);
        card.hass = environment.hass;
      });

      const modeSelect = document.getElementById("interaction-mode");
      const doubleTapInput = document.getElementById("doubletap-window");
      const longPressSelect = document.getElementById("longpress-action");

      function applyInteractionConfig() {
        const mode = modeSelect?.value ?? "restart";
        const doubleTapWindow = Math.min(500, Math.max(200, Number(doubleTapInput?.value ?? 300)));
        const longPressAction = longPressSelect?.value ?? "restart";

        const config = { ...baseConfig };
        if (mode === "pause-double") {
          config.tapActionMode = "pause_resume";
          config.doubleTapRestartEnabled = true;
          config.doubleTapWindowMs = doubleTapWindow;
          config.longPressAction = "none";
        } else if (mode === "pause-long") {
          config.tapActionMode = "pause_resume";
          config.longPressAction = longPressAction;
          config.doubleTapRestartEnabled = false;
        }

        configs[0] = config;
        cards[0]?.setConfig(config);
      }

      if (modeSelect && doubleTapInput && longPressSelect) {
        modeSelect.addEventListener("change", () => {
          const mode = modeSelect.value;
          doubleTapInput.disabled = mode !== "pause-double";
          longPressSelect.disabled = mode !== "pause-long";
          applyInteractionConfig();
        });

        doubleTapInput.addEventListener("change", () => {
          if (!doubleTapInput.disabled) {
            applyInteractionConfig();
          }
        });

        longPressSelect.addEventListener("change", () => {
          if (!longPressSelect.disabled) {
            applyInteractionConfig();
          }
        });

        doubleTapInput.disabled = modeSelect.value !== "pause-double";
        longPressSelect.disabled = modeSelect.value !== "pause-long";
        applyInteractionConfig();
      }

      const automationLog = document.getElementById("automation-log");

      function logAutomationEvent(data) {
        if (!automationLog) {
          return;
        }

        const eventTime = performance.now();
        const entry = document.createElement("li");
        entry.innerHTML = `
          <strong>${new Date().toLocaleTimeString()}</strong>
          — timer.finished fired for <code>${data.entity_id}</code>
        `;
        automationLog.prepend(entry);

        cards.forEach((card, index) => {
          card.updateComplete.then(() => {
            const status = card.shadowRoot?.querySelector(".status-pill");
            if (!status) {
              return;
            }

            const delayMs = Math.round(performance.now() - eventTime);
            const statusText = status.textContent ?? "";
            const item = document.createElement("div");
            item.textContent = `Card ${index + 1}: ${statusText.trim()} after ~${delayMs} ms`;
            entry.appendChild(item);
          });
        });

        while (automationLog.childElementCount > 6) {
          automationLog.lastElementChild?.remove();
        }
      }

      environment.connection
        .subscribeMessage((event) => {
          if (event?.event_type !== "timer.finished") {
            return;
          }

          if (event.data?.entity_id === "timer.kitchen_tea") {
            logAutomationEvent(event.data);
          }
        }, { type: "subscribe_events", event_type: "timer.finished" })
        .catch(() => {});

      document.getElementById("btn-idle").addEventListener("click", () => environment.setIdle());
      document.getElementById("btn-run").addEventListener("click", () => environment.setRunning(150, true, 150));
      document.getElementById("btn-estimate").addEventListener("click", () => environment.setRunning(120, false, 240));
      document.getElementById("btn-finish").addEventListener("click", () => environment.emitFinished());
      document.getElementById("btn-unavailable").addEventListener("click", () => environment.setUnavailable());
      document.getElementById("btn-disconnect").addEventListener("click", () => environment.disconnect());
      document.getElementById("btn-reconnect").addEventListener("click", () => environment.reconnect());
      document.getElementById("btn-fail-service").addEventListener("click", () => environment.failNextServiceCall());
    </script>
  </body>
</html>
