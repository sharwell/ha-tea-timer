<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Tea Timer Card Preview</title>
    <script type="module" src="../src/index.ts"></script>
    <style>
      body {
        margin: 0;
        padding: 32px;
        font-family: sans-serif;
        background: #f5f7fa;
      }

      main {
        display: grid;
        gap: 24px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 24px;
      }

      .controls button {
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: white;
        cursor: pointer;
      }

      .controls button:active {
        transform: translateY(1px);
      }

      .automation {
        margin-top: 24px;
        background: white;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 12px;
        padding: 16px;
      }

      .automation h2 {
        margin: 0 0 8px;
        font-size: 1.1rem;
      }

      .automation ol {
        margin: 12px 0 0;
        padding-left: 24px;
        display: grid;
        gap: 8px;
        font-variant-numeric: tabular-nums;
      }
    </style>
  </head>
  <body>
    <h1>Tea Timer Card Preview</h1>
    <main>
      <tea-timer-card></tea-timer-card>
      <tea-timer-card></tea-timer-card>
    </main>
    <section class="controls" aria-label="Timer controls">
      <button type="button" id="btn-idle">Set idle</button>
      <button type="button" id="btn-run">Set running (2:30)</button>
      <button type="button" id="btn-estimate">Set running (estimated)</button>
      <button type="button" id="btn-finish">Emit finished event</button>
      <button type="button" id="btn-unavailable">Mark unavailable</button>
    </section>
    <section class="automation" aria-label="Demo automation log">
      <h2>Automation listener</h2>
      <p>
        This demo automation listens for <code>timer.finished</code> on
        <code>timer.kitchen_tea</code> and logs the finish time. The entries below include the
        approximate delay until the card overlay reports "Done".
      </p>
      <ol id="automation-log" reversed></ol>
    </section>
    <script type="module">
      class DemoConnection {
        constructor() {
          this._listeners = new Map();
        }

        async subscribeMessage(callback, message) {
          const eventType = message?.event_type;
          if (!eventType) {
            return () => {};
          }

          const listeners = this._listeners.get(eventType) ?? new Set();
          listeners.add(callback);
          this._listeners.set(eventType, listeners);

          return () => {
            listeners.delete(callback);
          };
        }

        emit(eventType, data) {
          const listeners = this._listeners.get(eventType);
          if (!listeners) {
            return;
          }

          const message = { event_type: eventType, data };
          listeners.forEach((listener) => listener(message));
        }
      }

      function toDuration(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60)
          .toString()
          .padStart(2, "0");
        const seconds = Math.floor(totalSeconds % 60)
          .toString()
          .padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      }

      function createEntity(entityId, state, durationSeconds, remainingSeconds) {
        const now = new Date();
        return {
          entity_id: entityId,
          state,
          attributes: {
            duration: toDuration(durationSeconds),
            ...(remainingSeconds !== undefined ? { remaining: toDuration(remainingSeconds) } : {}),
          },
          last_changed: now.toISOString(),
          last_updated: now.toISOString(),
        };
      }

      function createDemoEnvironment(entityId, durationSeconds = 240) {
        const connection = new DemoConnection();
        const states = {};
        let current = createEntity(entityId, "idle", durationSeconds, durationSeconds);
        states[entityId] = current;

        const hass = {
          locale: { language: "en" },
          states,
          connection,
        };

        function emitState(newState) {
          const oldState = current;
          current = newState;
          states[entityId] = newState;
          connection.emit("state_changed", {
            entity_id: entityId,
            old_state: oldState,
            new_state: newState,
          });
        }

        return {
          hass,
          connection,
          setIdle() {
            emitState(createEntity(entityId, "idle", durationSeconds, durationSeconds));
          },
          setRunning(remainingSeconds, includeRemaining = true) {
            const remaining = includeRemaining ? remainingSeconds : undefined;
            const entity = createEntity(entityId, "active", durationSeconds, remaining);
            if (!includeRemaining && remainingSeconds !== undefined) {
              const lastChanged = new Date(Date.now() - (durationSeconds - remainingSeconds) * 1000).toISOString();
              entity.last_changed = lastChanged;
              entity.last_updated = lastChanged;
            }
            emitState(entity);
          },
          setUnavailable() {
            const now = new Date().toISOString();
            emitState({
              entity_id: entityId,
              state: "unavailable",
              attributes: {},
              last_changed: now,
              last_updated: now,
            });
          },
          emitFinished() {
            connection.emit("timer.finished", {
              entity_id: entityId,
            });
            setTimeout(() => {
              this.setIdle();
            }, 400);
          },
        };
      }

      const cards = Array.from(document.querySelectorAll("tea-timer-card"));
      const configs = [
        {
          title: "Kitchen Tea Timer",
          entity: "timer.kitchen_tea",
          defaultPreset: "Black",
          presets: [
            { label: "Green", durationSeconds: 120 },
            { label: "Black", durationSeconds: 240 },
            { label: "Herbal", durationSeconds: 300 },
          ],
        },
        {
          title: "Office Break Timer",
          presets: [],
        },
      ];

      const environment = createDemoEnvironment("timer.kitchen_tea", 240);
      cards.forEach((card, index) => {
        card.setConfig(configs[index]);
        card.hass = environment.hass;
      });

      const automationLog = document.getElementById("automation-log");

      function logAutomationEvent(data) {
        if (!automationLog) {
          return;
        }

        const eventTime = performance.now();
        const entry = document.createElement("li");
        entry.innerHTML = `
          <strong>${new Date().toLocaleTimeString()}</strong>
          â€” timer.finished fired for <code>${data.entity_id}</code>
        `;
        automationLog.prepend(entry);

        cards.forEach((card, index) => {
          card.updateComplete.then(() => {
            const status = card.shadowRoot?.querySelector(".status-pill");
            if (!status) {
              return;
            }

            const delayMs = Math.round(performance.now() - eventTime);
            const statusText = status.textContent ?? "";
            const item = document.createElement("div");
            item.textContent = `Card ${index + 1}: ${statusText.trim()} after ~${delayMs} ms`;
            entry.appendChild(item);
          });
        });

        while (automationLog.childElementCount > 6) {
          automationLog.lastElementChild?.remove();
        }
      }

      environment.connection
        .subscribeMessage((event) => {
          if (event?.event_type !== "timer.finished") {
            return;
          }

          if (event.data?.entity_id === "timer.kitchen_tea") {
            logAutomationEvent(event.data);
          }
        }, { type: "subscribe_events", event_type: "timer.finished" })
        .catch(() => {});

      document.getElementById("btn-idle").addEventListener("click", () => environment.setIdle());
      document.getElementById("btn-run").addEventListener("click", () => environment.setRunning(150));
      document.getElementById("btn-estimate").addEventListener("click", () => environment.setRunning(120, false));
      document.getElementById("btn-finish").addEventListener("click", () => environment.emitFinished());
      document.getElementById("btn-unavailable").addEventListener("click", () => environment.setUnavailable());
    </script>
  </body>
</html>
