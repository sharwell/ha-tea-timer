<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Tea Timer Card Preview</title>
    <script type="module" src="../src/index.ts"></script>
    <style>
      body {
        margin: 0;
        padding: 32px;
        font-family: sans-serif;
        background: #f5f7fa;
      }

      main {
        display: grid;
        gap: 24px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .appearance {
        margin-top: 24px;
        background: white;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 12px;
        padding: 16px;
        max-width: 480px;
      }

      .appearance h2 {
        margin: 0 0 8px;
        font-size: 1.1rem;
      }

      .appearance p {
        margin: 0;
        color: rgba(15, 23, 42, 0.72);
        line-height: 1.5;
      }

      .appearance-control {
        display: flex;
        flex-direction: column;
        gap: 4px;
        margin-top: 16px;
      }

      .appearance-control label {
        font-weight: 600;
      }

      .appearance-control select {
        padding: 8px 10px;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        font-size: 0.95rem;
        background: white;
        color: #111827;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 24px;
      }

      .controls button {
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: white;
        cursor: pointer;
      }

      .controls button:active {
        transform: translateY(1px);
      }

      .automation {
        margin-top: 24px;
        background: white;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 12px;
        padding: 16px;
      }

      .automation h2 {
        margin: 0 0 8px;
        font-size: 1.1rem;
      }

      .automation ol {
        margin: 12px 0 0;
        padding-left: 24px;
        display: grid;
        gap: 8px;
        font-variant-numeric: tabular-nums;
      }
    </style>
  </head>
  <body>
    <h1>Tea Timer Card Preview</h1>
    <main>
      <tea-timer-card></tea-timer-card>
      <tea-timer-card></tea-timer-card>
    </main>
    <section class="appearance" aria-label="Appearance options">
      <h2>Appearance</h2>
      <p>
        Preview theming tokens and per-preset colors. Changes apply to the first card above so you
        can contrast presets side-by-side.
      </p>
      <div class="appearance-control">
        <label for="layout-density">Layout density</label>
        <select id="layout-density">
          <option value="auto">Auto (responsive)</option>
          <option value="compact">Compact</option>
          <option value="regular">Regular</option>
        </select>
      </div>
      <div class="appearance-control">
        <label for="theme-select">Theme tokens</label>
        <select id="theme-select">
          <option value="inherit">Inherit (Home Assistant)</option>
          <option value="sunset">Sunset Glow</option>
          <option value="midnight">Midnight Brew</option>
          <option value="contrast">High Contrast</option>
        </select>
      </div>
      <div class="appearance-control">
        <label for="preset-palette">Preset palette</label>
        <select id="preset-palette">
          <option value="neutral">Neutral (no preset colors)</option>
          <option value="tea-flight">Tea Flight</option>
          <option value="citrus">Citrus Zest</option>
        </select>
      </div>
    </section>
    <section class="controls" aria-label="Timer controls">
      <button type="button" id="btn-idle">Set idle</button>
      <button type="button" id="btn-run">Set running (2:30)</button>
      <button type="button" id="btn-estimate">Set running (estimated)</button>
      <button type="button" id="btn-finish">Emit finished event</button>
      <button type="button" id="btn-unavailable">Mark unavailable</button>
      <button type="button" id="btn-disconnect">Disconnect</button>
      <button type="button" id="btn-reconnect">Reconnect</button>
      <button type="button" id="btn-fail-service">Fail next service call</button>
    </section>
    <section class="automation" aria-label="Demo automation log">
      <h2>Automation listener</h2>
      <p>
        This demo automation listens for <code>timer.finished</code> on
        <code>timer.kitchen_tea</code> and logs the finish time. The entries below include the
        approximate delay until the card overlay reports "Done".
      </p>
      <ol id="automation-log" reversed></ol>
    </section>
    <script type="module">
      const READY_STATES = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 };

      class DemoSocket {
        constructor() {
          this.readyState = READY_STATES.OPEN;
          this._listeners = new Map();
        }

        addEventListener(type, handler) {
          const listeners = this._listeners.get(type) ?? new Set();
          listeners.add(handler);
          this._listeners.set(type, listeners);
        }

        removeEventListener(type, handler) {
          this._listeners.get(type)?.delete(handler);
        }

        _emit(type) {
          const listeners = Array.from(this._listeners.get(type) ?? []);
          listeners.forEach((listener) => {
            try {
              listener({});
            } catch (error) {
              console.error(error);
            }
          });
        }

        close() {
          if (this.readyState === READY_STATES.CLOSED) {
            return;
          }
          this.readyState = READY_STATES.CLOSED;
          this._emit("close");
        }

        open() {
          this.readyState = READY_STATES.OPEN;
          this._emit("open");
        }

        error() {
          this._emit("error");
        }
      }

      class DemoConnection {
        constructor() {
          this._listeners = new Map();
          this.socket = new DemoSocket();
        }

        async subscribeMessage(callback, message) {
          const eventType = message?.event_type;
          if (!eventType) {
            return () => {};
          }

          const listeners = this._listeners.get(eventType) ?? new Set();
          listeners.add(callback);
          this._listeners.set(eventType, listeners);

          return () => {
            listeners.delete(callback);
          };
        }

        emit(eventType, data) {
          const listeners = this._listeners.get(eventType);
          if (!listeners) {
            return;
          }

          const message = { event_type: eventType, data };
          listeners.forEach((listener) => listener(message));
        }
      }

      function toDuration(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60)
          .toString()
          .padStart(2, "0");
        const seconds = Math.floor(totalSeconds % 60)
          .toString()
          .padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      }

      function createEntity(entityId, state, durationSeconds, remainingSeconds) {
        const now = new Date();
        return {
          entity_id: entityId,
          state,
          attributes: {
            duration: toDuration(durationSeconds),
            ...(remainingSeconds !== undefined ? { remaining: toDuration(remainingSeconds) } : {}),
          },
          last_changed: now.toISOString(),
          last_updated: now.toISOString(),
        };
      }

      function cloneEntity(entity) {
        return JSON.parse(JSON.stringify(entity));
      }

      function createDemoEnvironment(entityId, initialDurationSeconds = 240) {
        const environment = {};
        const connection = new DemoConnection();
        const states = {};
        let durationSeconds = initialDurationSeconds;
        let current = createEntity(entityId, "idle", durationSeconds, durationSeconds);
        let finishTimerHandle;
        let timerEndTimestamp;
        let pausedRemainingSeconds;
        let shouldFailCall = false;
        states[entityId] = current;

        function emitState(newState) {
          const oldState = current;
          current = newState;
          states[entityId] = newState;
          connection.emit("state_changed", {
            entity_id: entityId,
            old_state: oldState,
            new_state: newState,
          });
        }

        function clearFinishTimer() {
          if (finishTimerHandle !== undefined) {
            clearTimeout(finishTimerHandle);
            finishTimerHandle = undefined;
          }
        }

        function scheduleFinish(secondsRemaining) {
          clearFinishTimer();
          if (secondsRemaining <= 0) {
            Promise.resolve().then(() => environment.emitFinished());
            return;
          }

          finishTimerHandle = setTimeout(() => {
            finishTimerHandle = undefined;
            environment.emitFinished();
          }, secondsRemaining * 1000);
        }

        function getRemainingSeconds() {
          if (current.state === "paused") {
            return pausedRemainingSeconds ?? durationSeconds;
          }

          if (current.state === "active") {
            if (typeof timerEndTimestamp === "number") {
              return Math.max(0, Math.ceil((timerEndTimestamp - Date.now()) / 1000));
            }
            return durationSeconds;
          }

          return durationSeconds;
        }

        Object.assign(environment, {
          connection,
          hass: {
            locale: { language: "en" },
            states,
            connection,
            services: {
              timer: {
                start: {},
                cancel: {},
                change: {},
                pause: {},
              },
            },
            async callService(domain, service, data) {
              if (shouldFailCall) {
                shouldFailCall = false;
                throw new Error("demo service failure");
              }

              if (domain !== "timer") {
                return undefined;
              }

              if (service === "start") {
                const hasDuration = data && data.duration !== undefined;
                const requestedDuration = hasDuration ? Number(data.duration) : undefined;
                const isResume = !hasDuration && current.state === "paused";

                if (isResume) {
                  const resumeSeconds = getRemainingSeconds();
                  environment.setRunning(resumeSeconds, true);
                  connection.emit("timer.restarted", { entity_id: entityId });
                  return undefined;
                }

                const runDuration = Math.max(1, Number.isFinite(requestedDuration) ? Number(requestedDuration) : durationSeconds);
                durationSeconds = runDuration;
                environment.setRunning(runDuration, true, runDuration);
                connection.emit("timer.started", { entity_id: entityId });
                return undefined;
              }

              if (service === "cancel") {
                environment.setIdle();
                return undefined;
              }

               if (service === "pause") {
                 const remaining = getRemainingSeconds();
                 environment.setPaused(remaining);
                 connection.emit("timer.paused", { entity_id: entityId });
                 return undefined;
               }

               if (service === "change") {
                 const deltaSeconds = Number(data?.duration ?? 0);
                 if (!Number.isFinite(deltaSeconds) || deltaSeconds === 0) {
                   return undefined;
                 }

                 const updated = Math.max(0, getRemainingSeconds() + deltaSeconds);
                 if (current.state === "paused") {
                   environment.setPaused(updated);
                 } else if (current.state === "active") {
                   environment.setRunning(updated, true);
                 }
                 return undefined;
               }

              return undefined;
            },
          },
          setIdle() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            emitState(createEntity(entityId, "idle", durationSeconds, durationSeconds));
          },
          setRunning(remainingSeconds, includeRemaining = true, totalDurationSeconds = durationSeconds) {
            const safeTotal = Math.max(1, Math.round(totalDurationSeconds));
            const safeRemaining = Math.max(0, Math.round(remainingSeconds ?? safeTotal));
            durationSeconds = safeTotal;
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = Date.now() + safeRemaining * 1000;
            const remaining = includeRemaining ? safeRemaining : undefined;
            const entity = createEntity(entityId, "active", durationSeconds, remaining);
            if (!includeRemaining && safeRemaining <= durationSeconds) {
              const startTime = Date.now() - (durationSeconds - safeRemaining) * 1000;
              const lastChanged = new Date(startTime).toISOString();
              entity.last_changed = lastChanged;
              entity.last_updated = lastChanged;
            }
            emitState(entity);
            scheduleFinish(safeRemaining);
          },
          setPaused(remainingSeconds) {
            const safeRemaining = Math.max(0, Math.round(remainingSeconds ?? getRemainingSeconds()));
            pausedRemainingSeconds = safeRemaining;
            timerEndTimestamp = undefined;
            clearFinishTimer();
            emitState(createEntity(entityId, "paused", durationSeconds, safeRemaining));
          },
          setUnavailable() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            const now = new Date().toISOString();
            emitState({
              entity_id: entityId,
              state: "unavailable",
              attributes: {},
              last_changed: now,
              last_updated: now,
            });
          },
          emitFinished() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            connection.emit("timer.finished", {
              entity_id: entityId,
            });
            setTimeout(() => {
              environment.setIdle();
            }, 400);
          },
          disconnect() {
            connection.socket.close();
          },
          reconnect() {
            connection.socket.open();
            emitState(cloneEntity(current));
          },
          failNextServiceCall() {
            shouldFailCall = true;
          },
        });

        return environment;
      }

      const cards = Array.from(document.querySelectorAll("tea-timer-card"));
      const THEME_PRESETS = {
        inherit: {},
        sunset: {
          tokens: {
            "--ttc-bg": "#fff7ed",
            "--ttc-fg": "#7c2d12",
            "--ttc-accent": "#fb923c",
            "--ttc-dial-track": "#fed7aa",
            "--ttc-dial-progress": "#ea580c",
            "--ttc-chip-bg": "#fed7aa",
            "--ttc-chip-fg": "#7c2d12",
            "--ttc-chip-selected-bg": "#f97316",
            "--ttc-chip-selected-fg": "#ffffff",
            "--ttc-danger": "#b91c1c",
            "--ttc-focus-ring": "#fb923c",
          },
        },
        midnight: {
          tokens: {
            "--ttc-bg": "#0f172a",
            "--ttc-fg": "#e2e8f0",
            "--ttc-accent": "#38bdf8",
            "--ttc-dial-track": "rgba(148, 163, 184, 0.35)",
            "--ttc-dial-progress": "#38bdf8",
            "--ttc-chip-bg": "rgba(148, 163, 184, 0.25)",
            "--ttc-chip-fg": "#e2e8f0",
            "--ttc-chip-selected-bg": "#1d4ed8",
            "--ttc-chip-selected-fg": "#f8fafc",
            "--ttc-danger": "#f87171",
            "--ttc-focus-ring": "#e0f2fe",
          },
        },
        contrast: {
          tokens: {
            "--ttc-bg": "#0b1120",
            "--ttc-fg": "#f8fafc",
            "--ttc-accent": "#facc15",
            "--ttc-dial-track": "#1e293b",
            "--ttc-dial-progress": "#facc15",
            "--ttc-chip-bg": "#1f2937",
            "--ttc-chip-fg": "#f8fafc",
            "--ttc-chip-selected-bg": "#facc15",
            "--ttc-chip-selected-fg": "#111827",
            "--ttc-danger": "#f87171",
            "--ttc-focus-ring": "#facc15",
          },
        },
      };

      const PRESET_PALETTES = {
        neutral: { colors: [] },
        "tea-flight": {
          colors: [
            { match: "Green", color: "#2f855a", icon: "mdi:leaf" },
            { match: "Black", color: "#1f2937", icon: "mdi:coffee" },
            { match: "Herbal", color: "#be123c", icon: "mdi:flower" },
          ],
        },
        citrus: {
          colors: [
            { match: "Green", color: "#0f766e", icon: "mdi:leaf" },
            { match: "Black", color: "#f97316", icon: "mdi:cup-steam" },
            { match: "Herbal", color: "#facc15", icon: "mdi:flower" },
          ],
        },
      };

      const baseCardConfigs = [
        {
          allowAppearance: true,
          config: {
            title: "Kitchen Tea Timer",
            entity: "timer.kitchen_tea",
            defaultPreset: "Black",
            presets: [
              { label: "Green", durationSeconds: 120 },
              { label: "Black", durationSeconds: 240 },
              { label: "Herbal", durationSeconds: 300 },
            ],
          },
        },
        {
          allowAppearance: false,
          config: {
            title: "Office Break Timer",
            presets: [],
          },
        },
      ];

      const appearanceState = {
        density: "auto",
        theme: "inherit",
        palette: "neutral",
      };

      const environment = createDemoEnvironment("timer.kitchen_tea", 240);

      function cloneConfig(value) {
        return JSON.parse(JSON.stringify(value));
      }

      function resolveThemeTokens(key) {
        const theme = THEME_PRESETS[key];
        if (!theme || !theme.tokens) {
          return undefined;
        }
        return { ...theme.tokens };
      }

      function applyPresetPalette(presets, paletteKey) {
        const palette = PRESET_PALETTES[paletteKey];
        if (!palette || !Array.isArray(palette.colors) || palette.colors.length === 0) {
          return presets.map((preset) => ({ ...preset }));
        }

        return presets.map((preset, index) => {
          const match = palette.colors.find(
            (candidate) =>
              typeof candidate.match === "string" &&
              candidate.match.toLowerCase() === preset.label.toLowerCase(),
          );
          const colorDef = match ?? palette.colors[index % palette.colors.length];
          const next = { ...preset };
          if (colorDef.color) {
            next.color = colorDef.color;
          }
          if (colorDef.icon) {
            next.icon = colorDef.icon;
          }
          return next;
        });
      }

      function buildConfig(base, state) {
        const config = cloneConfig(base.config);
        if (base.allowAppearance) {
          config.layoutDensity = state.density;

          const tokens = resolveThemeTokens(state.theme);
          if (tokens) {
            config.themeTokens = tokens;
          } else {
            delete config.themeTokens;
          }

          if (Array.isArray(config.presets) && config.presets.length > 0) {
            config.presets = applyPresetPalette(config.presets, state.palette);
          }
        }

        return config;
      }

      function refreshCards() {
        cards.forEach((card, index) => {
          const base = baseCardConfigs[index] ?? baseCardConfigs[baseCardConfigs.length - 1];
          const config = buildConfig(base, appearanceState);
          card.setConfig(config);
          card.hass = environment.hass;
        });
      }

      refreshCards();

      const themeSelect = document.getElementById("theme-select");
      if (themeSelect instanceof HTMLSelectElement) {
        themeSelect.addEventListener("change", (event) => {
          const value = event.target.value;
          appearanceState.theme = value in THEME_PRESETS ? value : "inherit";
          refreshCards();
        });
      }

      const densitySelect = document.getElementById("layout-density");
      if (densitySelect instanceof HTMLSelectElement) {
        densitySelect.addEventListener("change", (event) => {
          const value = event.target.value;
          if (value === "compact" || value === "regular") {
            appearanceState.density = value;
          } else {
            appearanceState.density = "auto";
          }
          refreshCards();
        });
      }

      const presetSelect = document.getElementById("preset-palette");
      if (presetSelect instanceof HTMLSelectElement) {
        presetSelect.addEventListener("change", (event) => {
          const value = event.target.value;
          appearanceState.palette = value in PRESET_PALETTES ? value : "neutral";
          refreshCards();
        });
      }

      const automationLog = document.getElementById("automation-log");

      function logAutomationEvent(data) {
        if (!automationLog) {
          return;
        }

        const eventTime = performance.now();
        const entry = document.createElement("li");
        entry.innerHTML = `
          <strong>${new Date().toLocaleTimeString()}</strong>
          — timer.finished fired for <code>${data.entity_id}</code>
        `;
        automationLog.prepend(entry);

        cards.forEach((card, index) => {
          card.updateComplete.then(() => {
            const status = card.shadowRoot?.querySelector(".status-pill");
            if (!status) {
              return;
            }

            const delayMs = Math.round(performance.now() - eventTime);
            const statusText = status.textContent ?? "";
            const item = document.createElement("div");
            item.textContent = `Card ${index + 1}: ${statusText.trim()} after ~${delayMs} ms`;
            entry.appendChild(item);
          });
        });

        while (automationLog.childElementCount > 6) {
          automationLog.lastElementChild?.remove();
        }
      }

      environment.connection
        .subscribeMessage((event) => {
          if (event?.event_type !== "timer.finished") {
            return;
          }

          if (event.data?.entity_id === "timer.kitchen_tea") {
            logAutomationEvent(event.data);
          }
        }, { type: "subscribe_events", event_type: "timer.finished" })
        .catch(() => {});

      document.getElementById("btn-idle").addEventListener("click", () => environment.setIdle());
      document.getElementById("btn-run").addEventListener("click", () => environment.setRunning(150, true, 150));
      document.getElementById("btn-estimate").addEventListener("click", () => environment.setRunning(120, false, 240));
      document.getElementById("btn-finish").addEventListener("click", () => environment.emitFinished());
      document.getElementById("btn-unavailable").addEventListener("click", () => environment.setUnavailable());
      document.getElementById("btn-disconnect").addEventListener("click", () => environment.disconnect());
      document.getElementById("btn-reconnect").addEventListener("click", () => environment.reconnect());
      document.getElementById("btn-fail-service").addEventListener("click", () => environment.failNextServiceCall());
    </script>
  </body>
</html>
