<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Tea Timer Card Preview</title>
    <script type="module" src="../src/index.ts"></script>
    <style>
      body {
        margin: 0;
        padding: 32px;
        font-family: sans-serif;
        background: #f5f7fa;
      }

      main {
        display: grid;
        gap: 24px;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .dial-preview {
        background: white;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 12px;
        padding: 20px;
        display: grid;
        gap: 16px;
        justify-items: center;
      }

      .dial-preview h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .dial-preview-controls {
        display: flex;
        gap: 12px;
      }

      .dial-preview-controls label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 24px;
      }

      .controls button {
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: white;
        cursor: pointer;
      }

      .controls button:active {
        transform: translateY(1px);
      }

      .service-log {
        margin-top: 16px;
        padding: 16px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 12px;
        background: white;
      }

      .service-log .toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
      }

      .service-log input[type="checkbox"] {
        width: 18px;
        height: 18px;
      }

      .service-log ol {
        margin: 12px 0 0;
        padding-left: 24px;
        display: grid;
        gap: 6px;
        font-variant-numeric: tabular-nums;
      }

      .service-log ol[hidden] {
        display: none;
      }

      .service-log code {
        font-size: 0.95rem;
      }

      .service-log .status {
        font-weight: 600;
        text-transform: uppercase;
      }

      .service-log .status[data-status="ok"] {
        color: #0f9d58;
      }

      .service-log .status[data-status="failed"] {
        color: #d93025;
      }

      .service-log .status[data-status="ignored"] {
        color: #5f6368;
      }

      .automation {
        margin-top: 24px;
        background: white;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 12px;
        padding: 16px;
      }

      .automation h2 {
        margin: 0 0 8px;
        font-size: 1.1rem;
      }

      .automation ol {
        margin: 12px 0 0;
        padding-left: 24px;
        display: grid;
        gap: 8px;
        font-variant-numeric: tabular-nums;
      }
    </style>
  </head>
  <body>
    <h1>Tea Timer Card Preview</h1>
    <main>
      <tea-timer-card></tea-timer-card>
      <tea-timer-card></tea-timer-card>
    </main>
    <section class="dial-preview" aria-label="Dial state preview">
      <h2>Dial state preview</h2>
      <tea-timer-dial id="preview-dial"></tea-timer-dial>
      <div class="dial-preview-controls" role="radiogroup" aria-label="Preview dial state">
        <label>
          <input type="radio" name="preview-state" value="idle" checked />
          Idle
        </label>
        <label>
          <input type="radio" name="preview-state" value="running" />
          Running
        </label>
        <label>
          <input type="radio" name="preview-state" value="finished" />
          Finished
        </label>
      </div>
    </section>
    <section class="controls" aria-label="Timer controls">
      <button type="button" id="btn-idle">Set idle</button>
      <button type="button" id="btn-run">Set running (2:30)</button>
      <button type="button" id="btn-estimate">Set running (estimated)</button>
      <button type="button" id="btn-finish">Emit finished event</button>
      <button type="button" id="btn-unavailable">Mark unavailable</button>
      <button type="button" id="btn-disconnect">Disconnect</button>
      <button type="button" id="btn-reconnect">Reconnect</button>
      <button type="button" id="btn-fail-service">Fail next service call</button>
    </section>
    <section class="service-log" aria-label="Service call log">
      <label class="toggle">
        <input type="checkbox" id="toggle-service-log" />
        Log Home Assistant callService invocations
      </label>
      <ol id="service-log" reversed hidden></ol>
    </section>
    <section class="automation" aria-label="Demo automation log">
      <h2>Automation listener</h2>
      <p>
        This demo automation listens for <code>timer.finished</code> on
        <code>timer.kitchen_tea</code> and logs the finish time. The entries below include the
        approximate delay until the card overlay reports "Done".
      </p>
      <ol id="automation-log" reversed></ol>
    </section>
    <script type="module">
      const READY_STATES = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 };

      const serviceLogList = document.getElementById("service-log");
      const serviceLogToggle = document.getElementById("toggle-service-log");
      const MAX_SERVICE_LOG_ENTRIES = 12;
      let serviceLogEnabled = false;

      function updateServiceLogVisibility() {
        if (!serviceLogList) {
          return;
        }

        const shouldShow = serviceLogEnabled && serviceLogList.childElementCount > 0;
        serviceLogList.hidden = !shouldShow;
      }

      function recordServiceCall(domain, service, data) {
        if (!serviceLogEnabled || !serviceLogList) {
          return null;
        }

        const entry = document.createElement("li");
        const timestamp = document.createElement("strong");
        timestamp.textContent = new Date().toLocaleTimeString();
        entry.append(timestamp, document.createTextNode(" — "));

        const serviceCode = document.createElement("code");
        serviceCode.textContent = `${domain}.${service}`;
        entry.append(serviceCode);

        if (data !== undefined) {
          entry.append(document.createTextNode(" "));
          const dataCode = document.createElement("code");
          try {
            dataCode.textContent = JSON.stringify(data);
          } catch (error) {
            dataCode.textContent = String(data);
          }
          entry.append(dataCode);
        }

        const statusSpan = document.createElement("span");
        statusSpan.className = "status";
        statusSpan.dataset.status = "pending";
        statusSpan.textContent = "pending";
        entry.append(document.createTextNode(" — "), statusSpan);

        serviceLogList.prepend(entry);
        while (serviceLogList.childElementCount > MAX_SERVICE_LOG_ENTRIES) {
          serviceLogList.lastElementChild?.remove();
        }

        updateServiceLogVisibility();

        return {
          mark(status) {
            statusSpan.textContent = status;
            statusSpan.dataset.status = status;
            updateServiceLogVisibility();
          },
        };
      }

      if (serviceLogToggle instanceof HTMLInputElement) {
        serviceLogEnabled = serviceLogToggle.checked;
        serviceLogToggle.addEventListener("change", () => {
          serviceLogEnabled = serviceLogToggle.checked;
          updateServiceLogVisibility();
        });
      }

      updateServiceLogVisibility();

      class DemoSocket {
        constructor() {
          this.readyState = READY_STATES.OPEN;
          this._listeners = new Map();
        }

        addEventListener(type, handler) {
          const listeners = this._listeners.get(type) ?? new Set();
          listeners.add(handler);
          this._listeners.set(type, listeners);
        }

        removeEventListener(type, handler) {
          this._listeners.get(type)?.delete(handler);
        }

        _emit(type) {
          const listeners = Array.from(this._listeners.get(type) ?? []);
          listeners.forEach((listener) => {
            try {
              listener({});
            } catch (error) {
              console.error(error);
            }
          });
        }

        close() {
          if (this.readyState === READY_STATES.CLOSED) {
            return;
          }
          this.readyState = READY_STATES.CLOSED;
          this._emit("close");
        }

        open() {
          this.readyState = READY_STATES.OPEN;
          this._emit("open");
        }

        error() {
          this._emit("error");
        }
      }

      class DemoConnection {
        constructor() {
          this._listeners = new Map();
          this.socket = new DemoSocket();
        }

        async subscribeMessage(callback, message) {
          const eventType = message?.event_type;
          if (!eventType) {
            return () => {};
          }

          const listeners = this._listeners.get(eventType) ?? new Set();
          listeners.add(callback);
          this._listeners.set(eventType, listeners);

          return () => {
            listeners.delete(callback);
          };
        }

        emit(eventType, data) {
          const listeners = this._listeners.get(eventType);
          if (!listeners) {
            return;
          }

          const message = { event_type: eventType, data };
          listeners.forEach((listener) => listener(message));
        }
      }

      function toDuration(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60)
          .toString()
          .padStart(2, "0");
        const seconds = Math.floor(totalSeconds % 60)
          .toString()
          .padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      }

      function createEntity(entityId, state, durationSeconds, remainingSeconds) {
        const now = new Date();
        return {
          entity_id: entityId,
          state,
          attributes: {
            duration: toDuration(durationSeconds),
            ...(remainingSeconds !== undefined ? { remaining: toDuration(remainingSeconds) } : {}),
          },
          last_changed: now.toISOString(),
          last_updated: now.toISOString(),
        };
      }

      function cloneEntity(entity) {
        return JSON.parse(JSON.stringify(entity));
      }

      function createDemoEnvironment(entityId, initialDurationSeconds = 240) {
        const environment = {};
        const connection = new DemoConnection();
        const states = {};
        let durationSeconds = initialDurationSeconds;
        let current = createEntity(entityId, "idle", durationSeconds, durationSeconds);
        let finishTimerHandle;
        let timerEndTimestamp;
        let pausedRemainingSeconds;
        let shouldFailCall = false;
        states[entityId] = current;

        function emitState(newState) {
          const oldState = current;
          current = newState;
          states[entityId] = newState;
          connection.emit("state_changed", {
            entity_id: entityId,
            old_state: oldState,
            new_state: newState,
          });
        }

        function clearFinishTimer() {
          if (finishTimerHandle !== undefined) {
            clearTimeout(finishTimerHandle);
            finishTimerHandle = undefined;
          }
        }

        function scheduleFinish(secondsRemaining) {
          clearFinishTimer();
          if (secondsRemaining <= 0) {
            Promise.resolve().then(() => environment.emitFinished());
            return;
          }

          finishTimerHandle = setTimeout(() => {
            finishTimerHandle = undefined;
            environment.emitFinished();
          }, secondsRemaining * 1000);
        }

        function getRemainingSeconds() {
          if (current.state === "paused") {
            return pausedRemainingSeconds ?? durationSeconds;
          }

          if (current.state === "active") {
            if (typeof timerEndTimestamp === "number") {
              return Math.max(0, Math.ceil((timerEndTimestamp - Date.now()) / 1000));
            }
            return durationSeconds;
          }

          return durationSeconds;
        }

        Object.assign(environment, {
          connection,
          hass: {
            locale: { language: "en" },
            states,
            connection,
            services: {
              timer: {
                start: {},
                cancel: {},
                change: {},
                pause: {},
              },
            },
            async callService(domain, service, data) {
              const logHandle = recordServiceCall(domain, service, data);
              let outcome = "ok";
              try {
                if (shouldFailCall) {
                  shouldFailCall = false;
                  outcome = "failed";
                  throw new Error("demo service failure");
                }

                if (domain !== "timer") {
                  outcome = "ignored";
                  return undefined;
                }

                if (service === "start") {
                  const hasDuration = data && data.duration !== undefined;
                  const requestedDuration = hasDuration ? Number(data.duration) : undefined;
                  const isResume = !hasDuration && current.state === "paused";

                  if (isResume) {
                    const resumeSeconds = getRemainingSeconds();
                    environment.setRunning(resumeSeconds, true);
                    connection.emit("timer.restarted", { entity_id: entityId });
                    return undefined;
                  }

                  const runDuration = Math.max(1, Number.isFinite(requestedDuration) ? Number(requestedDuration) : durationSeconds);
                  durationSeconds = runDuration;
                  environment.setRunning(runDuration, true, runDuration);
                  connection.emit("timer.started", { entity_id: entityId });
                  return undefined;
                }

                if (service === "cancel") {
                  environment.setIdle();
                  return undefined;
                }

                if (service === "pause") {
                  const remaining = getRemainingSeconds();
                  environment.setPaused(remaining);
                  connection.emit("timer.paused", { entity_id: entityId });
                  return undefined;
                }

                if (service === "change") {
                  const deltaSeconds = Number(data?.duration ?? 0);
                  if (!Number.isFinite(deltaSeconds) || deltaSeconds === 0) {
                    outcome = "ignored";
                    return undefined;
                  }

                  const updated = Math.max(0, getRemainingSeconds() + deltaSeconds);
                  if (current.state === "paused") {
                    environment.setPaused(updated);
                  } else if (current.state === "active") {
                    environment.setRunning(updated, true);
                  }
                  return undefined;
                }

                outcome = "ignored";
                return undefined;
              } catch (error) {
                outcome = "failed";
                throw error;
              } finally {
                if (logHandle) {
                  logHandle.mark(outcome);
                }
              }
            },
          },
          setIdle() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            emitState(createEntity(entityId, "idle", durationSeconds, durationSeconds));
          },
          setRunning(remainingSeconds, includeRemaining = true, totalDurationSeconds = durationSeconds) {
            const safeTotal = Math.max(1, Math.round(totalDurationSeconds));
            const safeRemaining = Math.max(0, Math.round(remainingSeconds ?? safeTotal));
            durationSeconds = safeTotal;
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = Date.now() + safeRemaining * 1000;
            const remaining = includeRemaining ? safeRemaining : undefined;
            const entity = createEntity(entityId, "active", durationSeconds, remaining);
            if (!includeRemaining && safeRemaining <= durationSeconds) {
              const startTime = Date.now() - (durationSeconds - safeRemaining) * 1000;
              const lastChanged = new Date(startTime).toISOString();
              entity.last_changed = lastChanged;
              entity.last_updated = lastChanged;
            }
            emitState(entity);
            scheduleFinish(safeRemaining);
          },
          setPaused(remainingSeconds) {
            const safeRemaining = Math.max(0, Math.round(remainingSeconds ?? getRemainingSeconds()));
            pausedRemainingSeconds = safeRemaining;
            timerEndTimestamp = undefined;
            clearFinishTimer();
            emitState(createEntity(entityId, "paused", durationSeconds, safeRemaining));
          },
          setUnavailable() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            const now = new Date().toISOString();
            emitState({
              entity_id: entityId,
              state: "unavailable",
              attributes: {},
              last_changed: now,
              last_updated: now,
            });
          },
          emitFinished() {
            clearFinishTimer();
            pausedRemainingSeconds = undefined;
            timerEndTimestamp = undefined;
            connection.emit("timer.finished", {
              entity_id: entityId,
            });
            setTimeout(() => {
              environment.setIdle();
            }, 400);
          },
          disconnect() {
            connection.socket.close();
          },
          reconnect() {
            connection.socket.open();
            emitState(cloneEntity(current));
          },
          failNextServiceCall() {
            shouldFailCall = true;
          },
        });

        return environment;
      }

      const cards = Array.from(document.querySelectorAll("tea-timer-card"));
      const configs = [
        {
          title: "Kitchen Tea Timer",
          entity: "timer.kitchen_tea",
          defaultPreset: "Black",
          presets: [
            { label: "Green", durationSeconds: 120 },
            { label: "Black", durationSeconds: 240 },
            { label: "Herbal", durationSeconds: 300 },
          ],
        },
        {
          title: "Office Break Timer",
          presets: [],
        },
      ];

      const environment = createDemoEnvironment("timer.kitchen_tea", 240);
      const previewDial = document.getElementById("preview-dial");

      cards.forEach((card, index) => {
        card.setConfig(configs[index]);
        card.hass = environment.hass;
      });

      function updatePreviewDial(state) {
        if (!previewDial || typeof previewDial.setProgressFraction !== "function") {
          return;
        }

        previewDial.bounds = { min: 15, max: 360, step: 5 };
        previewDial.value = state === "idle" ? 180 : 240;
        previewDial.valueText = state === "running" ? "2:30" : state === "finished" ? "Done" : "3:00";
        previewDial.interactive = state === "idle";
        previewDial.status = state === "finished" ? "finished" : state === "running" ? "running" : "idle";
        const fraction = state === "running" ? 0.6 : state === "finished" ? 1 : 0;
        previewDial.setProgressFraction(fraction);
      }

      updatePreviewDial("idle");

      document.querySelectorAll('input[name="preview-state"]').forEach((input) => {
        input.addEventListener("change", (event) => {
          const target = event.currentTarget;
          if (target instanceof HTMLInputElement && target.checked) {
            updatePreviewDial(target.value);
          }
        });
      });

      const automationLog = document.getElementById("automation-log");

      function logAutomationEvent(data) {
        if (!automationLog) {
          return;
        }

        const eventTime = performance.now();
        const entry = document.createElement("li");
        entry.innerHTML = `
          <strong>${new Date().toLocaleTimeString()}</strong>
          — timer.finished fired for <code>${data.entity_id}</code>
        `;
        automationLog.prepend(entry);

        cards.forEach((card, index) => {
          card.updateComplete.then(() => {
            const status = card.shadowRoot?.querySelector(".status-pill");
            if (!status) {
              return;
            }

            const delayMs = Math.round(performance.now() - eventTime);
            const statusText = status.textContent ?? "";
            const item = document.createElement("div");
            item.textContent = `Card ${index + 1}: ${statusText.trim()} after ~${delayMs} ms`;
            entry.appendChild(item);
          });
        });

        while (automationLog.childElementCount > 6) {
          automationLog.lastElementChild?.remove();
        }
      }

      environment.connection
        .subscribeMessage((event) => {
          if (event?.event_type !== "timer.finished") {
            return;
          }

          if (event.data?.entity_id === "timer.kitchen_tea") {
            logAutomationEvent(event.data);
          }
        }, { type: "subscribe_events", event_type: "timer.finished" })
        .catch(() => {});

      document.getElementById("btn-idle").addEventListener("click", () => environment.setIdle());
      document.getElementById("btn-run").addEventListener("click", () => environment.setRunning(150, true, 150));
      document.getElementById("btn-estimate").addEventListener("click", () => environment.setRunning(120, false, 240));
      document.getElementById("btn-finish").addEventListener("click", () => environment.emitFinished());
      document.getElementById("btn-unavailable").addEventListener("click", () => environment.setUnavailable());
      document.getElementById("btn-disconnect").addEventListener("click", () => environment.disconnect());
      document.getElementById("btn-reconnect").addEventListener("click", () => environment.reconnect());
      document.getElementById("btn-fail-service").addEventListener("click", () => environment.failNextServiceCall());
    </script>
  </body>
</html>
